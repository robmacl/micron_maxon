% Read calibration data generated by asap_calibration.vi
% This file contains information about:
%  -- commanded pose
%  -- uncalibrated sensor signals
%  -- runtime position measurement and position valid
% 
% The result is a struct with these fields:
%   axis_pos(point_ix, :, light_num): axis positions in sensor microns, 
%     see nominal_scale.m.  A 3D array, with rows organized by sensor:
%       [u1 v1 u2 v2]
%
%     the third dimension is indexed by the light number.
% 
%   amplitude(point_ix, :, light_num): signal amplitude for each
%     light and each axis.
%
%   poses(point_ix, :, pose_ix) Each row is a "pose vector" 
%       [x y z Rx Ry Rz] (units mm/degree, see pvec2tr, tr2pvec)
%
%     This assumes the data was taken in "Pose" mode.  If "Absolute axis" mode
%     was used, then you have to deal with the actual stage kinematics.  Stage
%     pose is poses(:,:,1), handle pose is poses(:,:,2) and output pose is
%     poses(:,:,3).
%
%   valid(point_ix): 1 when runtime pose and light data is valid, 0 otherwise.
%     The raw signals may be usable for some of lights even when valid has
%     been forced off because one or more lights is out of the FOV or turned
%     off.
% 
%   light_pos(point_ix, 1:3, light_num): positions of lights at runtime
%     [x, y, z, 1] (microns)
%   
%   match_err(point_ix, light_num): ray match error for light (microns.)


function [res] = read_data_motion_v2(filename)

rows = load(filename);

nread = 0;
[nread, stage_pose_slice] = row_slicer(nread, 6);
[nread, handle_pose_slice] = row_slicer(nread, 6);
[nread, output_pose_slice] = row_slicer(nread, 6);
[nread, valid_slice] = row_slicer(nread, 1);

% Demodulated signals: 2 sensors * 2 axes * 2 signals/axis = 8
% + 3 XYZ position + 1 match error = 12 signals/light.
num_signals = 12;
num_lights = (size(rows, 2) - nread)/num_signals;
[nread, light_signals_slice] = row_slicer(nread, num_lights * num_signals);

nrows = size(rows, 1); % number of rows

% Poses
stage_pose = rows(:, stage_pose_slice);
desired = pad_ones(stage_pose(:, 1:3) * 1e3);
res.poses = cat(3, stage_pose, ...
		rows(:, handle_pose_slice), ...
		rows(:, output_pose_slice));

% Runtime ASAP valid.
res.valid = (rows(:, valid_slice) ~= 0);

signals2 = rows(:, light_signals_slice);
signals3 = reshape(signals2, nrows, num_signals, num_lights);
res.light_pos = signals3(:, 9:11, :);
res.light_pos(:, 4, :) = 1;

res.match_err = signals3(:, 12, :);
demod = signals3(:, 1:8, :);
demod = reshape(demod, nrows, 2, 4, []);

measured = zeros(nrows, 4, num_lights);
amplitude = zeros(nrows, 4, num_lights);

% Find axis positions from the signal amplitudes using PSD formula.
for light_ix = 1:num_lights
  for axis_ix = 1:4
    a0 = demod(:, 1, axis_ix, light_ix);
    a1 = demod(:, 2, axis_ix, light_ix);
    sum = a1 + a0;
    amplitude(:, axis_ix, light_ix) = sum;
    measured(:, axis_ix, light_ix) = (a1 - a0) ./ sum;
  end
end

% Scale to sensor plane microns.
for light_ix = 1:num_lights
  measured(:, :, light_ix) = measured(:, :, light_ix) * nominal_scale;
end

res.axis_pos = measured;
res.amplitude = amplitude;
