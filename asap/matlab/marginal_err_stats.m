### this code was pulled out of check_poses.  It crunches a rectangular pose
    mesh, such as from check_mesh and generates marginal statistics, 
    but this wasn't seeming all that useful, largely because of the
    impossibility of densely sampling a 6DOF space, and also because
    the marginal statistics were a pretty indirect way to get at what
    what we need to know about cross-coupling.  check_poses is more
    useful without the constraint of grid data.
	
  
  % Figure out blocking of rotation and translation parts.  Before we
  % delete bad points, each translation should be used at each orientation
  % before stepping to the next orientation (as generated by check_mesh.m).
  rnd_nearest = 1e-3;
  first_rot = round(vposes(1, 4:6, 1) ./ 1e-3);
  trans_block = 1;
  while (trans_block < npoints ...
	 && ismember(first_rot, ...
		     round(vposes(trans_block + 1, 4:6, 1) ./ 1e-3), ...
		     'rows'))
    trans_block = trans_block + 1;
  end

  rot_block = npoints / trans_block;
  fprintf(1, 'Blocking: %d translation, %d orientation.\n', ...
	  trans_block, rot_block);


  % This represents the distinct orientation and translation parts of the
  % poses in a way that can be updated when invalid points are removed.
  % Each row corresponds to one of the data points, and the elements are
  % the integer IDs for the distinct translation and orientation parts.
  pose_parts = zeros(npoints, 2);
  ix = 1;
  for (o_ix = 1:rot_block)
    for (t_ix = 1:trans_block)
      pose_parts(ix, :) = [t_ix, o_ix];
      ix = ix + 1;
    end
  end
### code before this works on full data set, after on deleted points.   If
    this is going to be resurrected, then it needs to get access to the 
    poses before deletion and info about deletion
    
    
  pose_parts(~valid, :) = [];

  [o_mag, origin_ix] = min(sum(vposes(:,:,1).^2, 2));
  if (o_mag > 1e-6)
    fprintf(1, 'Didn''t find anything like a zero pose in data, aborting.\n');
  else
    fprintf(1, 'Origin index: %d (%d, %d)\n', origin_ix, ...
	    pose_parts(origin_ix, 1), pose_parts(origin_ix, 2));
  end

  

  % Build 2D pose_map, indexed by unique orientation and translation
  % (blocking factors)
  %   pose_map(trans_ix, rot_ix, 1:2, 1:6)
  %
  % (:, :, 1, :) is the desired pose vector at that point, and (:, :, 2, :) is
  % the error, in mm and degrees.  The measured is desired + error.  If there
  % is no measurement at that particular pose combination, then the entry is
  % zeros.
  pose_map = zeros(trans_block, rot_block, 2, 6);

  % 1 if the entry exists, 0 otherwise.
  pose_map_valid = zeros(trans_block, rot_block);
  
  for (ix = 1:npoints)
    pose_map(pose_parts(ix, 1), pose_parts(ix, 2), :, :) ...
	= [xyz_desired(ix, 1:3)*1e-3 squeeze(vposes(ix, 4:6, 1)) 
	   trans_err(ix, :)*1e-3 squeeze(rot_vecs(ix, :))];
    pose_map_valid(pose_parts(ix, 1), pose_parts(ix, 2)) = 1;
  end


  % Force error at origin to zero by offsetting all of the errors.  While this
  % doesn't result in the lowest overall error (as reported above), it gives
  % us a basis for comparing the magnitude of the error to the magnitude of
  % the pose.  Using subtraction isn't theoretically correct, but should work
  % since the error angles are small.  We offset the pose to force the
  % origin pose to precisely zero too, though it should already be quite close.
  origin_err = pose_map(pose_parts(origin_ix, 1), ... 
			pose_parts(origin_ix, 2), :, :);
  for (ix = 1:trans_block)
    for (jx = 1:rot_block)
      if (pose_map_valid(ix, jx))
	pose_map(ix, jx, :, :) = pose_map(ix, jx, :, :) - origin_err;
      end
    end
  end

  
  [rot_margin, rot_margin_vsum, rot_margin_max_var]=cp_marginal_stats(pose_map, pose_map_valid);
  [trans_margin, trans_margin_vsum, trans_margin_max_var] = ...
      cp_marginal_stats(permute(pose_map, [2, 1, 3, 4]), pose_map_valid');
  % cov([squeeze(rot_margin(:,1,4:6))  squeeze(rot_margin_vsum(:,2,2))])
