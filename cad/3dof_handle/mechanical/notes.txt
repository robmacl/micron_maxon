
Piezo arangement:
 -- everything depends on this.
 -- Diameter v.s. overlap kinematic problems
 -- kinematic tradeoffs Z v.s. XY for delta v.s. wye arrangement
 -- Free bore

Flexure:
 -- Determine wire diameter and and length based on required compliance
    to minimize interference.  
 -- Construction details.  How to anchor wire, design of interface w/
    piezo, disassembly capability.  Any standoff (hypo tube, etc.)

Output plate:
 -- Determine stiffness and strength required to not be excessively
    fragile and to not significantly degrade system stiffness.
 -- Determine proportions to optimize stiffness v.s. mass and moment
    of inertia. 
 -- LED mounting
 -- free bore
 -- Instead of building in Luer, maybe have female thread.  We can
    thread in Luer if we want it, or something else.  Facilitates
    threading the bore with different things.  Or a collet...  A
    collet or other clamp would allow threading in of connectorized
    fibers, etc., from the back. 

Base plate:
 -- determine mounting angles to acheive desired output plane.  Some
    measurement of actual piezo stack shape needed.
 -- wire routing to minimize size and avoid mechanical interference.
    flex design.
 -- piezo attachment design.  screw/clamp/rubber/alignment from end

ASAP mounting:
 -- locate lights w.r.t. housing openings.
 -- flex design

Housing:
 -- Cover guts, screw to baseplate, design grip, trochar, lights
    visible, cable clamp.
 -- Access to free bore?  Would be nice if it were possible to snake
    tools in from the back of the handle.  I suppose we could have a
    notch running the length of the grip that would be covered with
    tape.  Then it would only be necessary to thread the manipulator,
    not the entire tool.


Charge control issues:

It will do least violence to the existing code structure if we make a
seperate charge controller (analogous to the VC position controller)
that takes a stack position, compares it to the charge estimate and
outputs the difference as a current command.  We then update the
charge estimate accordingly.  The charge estimate is an integrator
whose drift is controlled by an offset estimate.  The offset estimate
is generated by integrating the difference between the stack voltage
and the ideal stack voltage based on the charge/capacitance.  So the
offset is estimated by a feedback loop.  The charge integrator is
indirectly zeroed by the offset because the offset is applied to the
output command.

If the current output is limiting (velocity limit), then we track
the actual charge we have pushed out.  We should not be in a large
signal slew limit often, but if the position has a lot of HF noise it
may cause slew limiting due to the differentiation that we do.  We
hope not, though because that would imply significant HF noise making
it though to the output.

The charge controller can internally enhance damping by using stack
dv/dt as a velocity estimate.  This can be based on the stack voltage
error that we already compute for the offset control loop.  This will
largely eliminate interference with the commanded motion, so avoid
affecting the overall feedback loop.

We could express most of this as a Kalman filter, and I guess that
could be advantageous if we incorporate a stack dynamic model that
includes the resonance.  But this is really just a more general
version of the KF-based controller idea, now with HF position info
from the stack voltage.  This is probably a good idea, but not a quick
hack, and as long as the ad-hoc approach works, there would probably
be no need to ever revisit this.


What parameters/configuration?

We want to be able to easily store and switch between parameters for
different setups.  This means that we want to bundle up parameters
that are basically static in a single type.  Some globals are for
communication, mode control, etc., and are not static.

Probably the best way to do this is to have an array of parameters
objects, and have some way to manage parameter sets.  Maybe we want
the basic ASAP/Micron VI to just specificy a parameter set name, and
then have a separate parameter editor that allows us to manage
parameter sets.

Maybe we want there to be one current config in a global, and then the
config manager allows editing this and saving new named versions.
This way you can fiddle with the paramaters without modifying any
saved config (though if we still use the array default value it's
going to take an extra step to actually save a modified config anyway.)

Rename xxx config to xxx state so that we can call configurations
configurations? 

ASAP configuration: frequencies, output rate, etc.
    remove probe cal from ASAP config
    make new ASAP parameters?
The asap calibration, LUT, etc. is sort of in this category too, but
we probably don't want to mess with that.

Probe calibration
    Depends on tool

Inverse kinematics
    Note that currently inverse kinematics depends on probe calibration

Controller parameters for the various controllers
    Will vary for different tools, though many similar tools may work
    with the same values.

cancellation parameters
    Varies depending on the application (and thus the tool) Probably
    hold and any new state related to cancellation mode (motion
    scaling, etc.) should not be in cancellation parameters.


Scanning parameters is more of an end-user interface kind of thing


Parallelism, etc.

A good idea to move the goal position/cancellation filter out of the
main loop, as this can even be run at a lower rate, saving CPU w/o any
parallelism.  This will become even more of a win as the complexity of
the cancellation is increased by motion scaling, keep away, scanning,
etc.  This would include the handle pose estimation, laser and pedal
control, etc.  This is an advantgeous simpilification of the inner
loop even from a purely conceptual standpoint.  We just stick the
current goal position in a shared variable that is read by the inner
cancellation loop.

Could also move the manipulator local feedback to a seperate loop,
which could potentially run at a higher rate.  If the voltage feedback
works well for damping the resonance, then we could potentially reduce
the ASAP data and cancellation loop rate, which would reduce noise as
well as saving computation.

The trace data mechanism would need to be modified to some degree as
we may want to log stuff outside of micron_update, such as the
manipulator loop state.

One idea is that instead of directly linearizing the stacks with a
lookup, we could linearize the whole manpiulator by doing local
calibrations at several points, and then switching the inverse
kinematics according to our location in the manipulator space.  This
will linearize the manpulator's mechanical nonlinearity as well as the
contribution of the stacks.  This would be linearizing the actual
manipulator characteristics, not just the theoretical nonlinearity of
the ideal parallel linkage.  For example, this will account for some
cross-coupling effects where we may load down due to interference in
corners of the manipulator space.  Note that the actual switching of
the inverse kinematics can be done outside of the main loop, possibly
at a lower rate.  This is advantageous compared to putting an
interpolation inside the critical loop.
